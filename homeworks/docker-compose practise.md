#### Задание: 

Необходимо развернуть несколько  
контейнеров вместе:  
1. Nginx с опцией постоянного перезапуска  
2. Redis  
3. Приложение на Python  
4. 2 контейнера MongoDB  
• Настроить volume, который хранит данные в /data/db  
• Разделить Frontend и Python на сетевом уровне (nginx  
должен быть везде, mongoDB – только с Python)  
• Настроить запуск контейнеров по порядку, как  
указано выше  
• Время: 45-60 минут

#### Описание: 

##### Dockerfile

В первую очередь я создал dockerfile для создания образа для python. И соотвественно создал файлик requirements.txt, там указаны зависимости (FastApi и uvicorn)
uvicorn - ASGI сервер, который используется для запуска приложений на основе FastAPI.

```
# установка базового образа 
FROM python:3.9-slim

# устанавливаем рабочую директорию 
WORKDIR /app

# копирование зависисмостей в рабочую директорию
COPY requirements.txt .

# установка зависимостей из файлов
RUN pip install --no-cache-dir --upgrade -r requirements.txt

# копируем все файлы в рабочую директорию из локал
COPY . .

#указываем порт 
EXPOSE 8000

#команда для запуска контейнера
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
```

Подробнее про команду для запуска сервера: 

Запускает сервер Uvicorn с приложением `app`, указывает, что сервер должен быть доступен на всех сетевых интерфейсах и указывает 8000 порт на котором будет запущено.


#### Конфиг файл nginx

На данном этапе был создан конфиг nginx

1. Определяетcz виртуальный сервер, который слушает порт 80 и обслуживает домен `localhost`.
2. Перенаправляет все запросы к корневому пути (`/`) на сервер `python-app` на порту 8000.
3. Устанавливаются заголовки `Host`, `X-Real-IP`, `X-Forwarded-For` и `X-Forwarded-Proto`, чтобы передать информацию о клиенте и протоколе на проксируемый сервер.

```
server {
    listen 80;
    server_name localhost;

    location / {
        proxy_pass http://python-app:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```


#### docker-compose 

1) **nginx**
	- будет создаваться из образа nginx-latest
	- задаем имя контейнеру nginx
	- задаем restart:always
	- указываем порты 
	- далее задаем сети frontend и backend по заданию 
	- также задаем volume, для сохранения данных, файл конфига из текущей директории будет смонтирован в контейнер nginx в директорию `/etc/nginx/conf.d/default.conf`
3) **redis**
	- создается из образа redis:latest
	- задаем имя контейнеру redis
	- задаем restart:always
	- для запуска контейнера по порядку указываем depends_on: nginx 
	- подключаем к сети backend
4) **python-app**
	- указываем что контейнер будет создаваться из Dockerfile (из текущей директории)
	- задаем имя контейнеру **python-app**
	- задаем restart:always
	- для запуска контейнера по порядку указываем depends_on: redis
	- подключаем к сети backend
5) mongodb
	- создается из образа mongo:latest
	- задаем restart:always
	- для запуска контейнера по порядку задаем depends_on
	- создаем volume для хранения данных mongodb
	- подключаем к сети backend
6) volumes
	-  Определяем том `mongo_data1`, который будет использоваться для хранения данных MongoDB
7) networks
	- определяем сети, которые будут использоваться сервисами
	- frontend - это имя сети, которая будет использоваться для сервисов, которые должны быть доступны извне
	- backend - это имя сети, которая будет использоваться для сервисов, которые должны взаимодействовать между собой внутри (например, Redis, Python-приложение, MongoDB).

По заданию нужно создать два контейнера MongoDB, изначальным рещением было создание двух сервисов для каждого контейнера, с раздельными volume, также в данном варианте можно задать разные порты или сети. Фактически это два сервиса которые можно конфигурировать.

```
mongodb1:
    image: mongo:latest
    container_name: mongodb1
    restart: always
    volumes:
      - mongo_data1:/data/db
    networks:
      - backend


  mongodb2:
    image: mongo:latest
    container_name: mongodb2
    restart: always
    volumes:
      - mongo_data2:/data/db
    networks:
      - backend
```

Но после просмотра записи занятия, в кейсе если понадобится больше контейнеров, поэтому я начал искать как в docker compose можно создавать реплики. Я нашел несколько решений, такие как использование replica set, scale, и директива deploy которая определяет параметры развертывания сервиса. 

Каждый из этих способов имеет особенности, в результате я решил использовать deploy c указанием количества реплик. При использовании данного способа я столкнулся со следующей проблемой, что нельзя указать разные порты для каждого из контейнеров, что приводит к тому что запускается фактически один контейнер, а реплика постоянно пытается запуститься, если указано restart:always. С другой стороны, в этом может быть плюс: если остановить один контейнер, второй сразу подключится, так как освободится порт, и так как реплика использует тот же volume, данные должны сохраниться.

```
  mongodb:
    image: mongo:latest
    restart: always
    depends_on:
      - nginx
      - redis
      - python-app
    deploy:
      replicas: 2
    volumes:
      - mongo_data1:/data/db
    networks:
      - backend
```

